# Java基础

以下是Java基础面试问题的简明答案：

## 1. **Java有哪些基本数据类型？它们的字节大小和默认值分别是什么？**

**答案**：

- **byte**：1字节，默认值`0`
- **short**：2字节，默认值`0`
- **int**：4字节，默认值`0`
- **long**：8字节，默认值`0L`
- **float**：4字节，默认值`0.0f`
- **double**：8字节，默认值`0.0d`
- **char**：2字节，默认值`'\u0000'`
- **boolean**：1位，默认值`false`

## 2. **`==`和`equals()`的区别是什么？**

**答案**：

- `==` 比较的是内存地址（引用）是否相等。
- `equals()` 比较的是对象内容是否相等，`Object`类默认实现是比较地址，但通常会重写来比较内容。

## 3. **面向对象编程的四大特性是什么？**

**答案**：

- **封装**：隐藏实现细节，暴露接口。
- **继承**：子类继承父类属性和方法。
- **多态**：父类引用指向子类对象，执行子类方法。
- **抽象**：定义模板方法，让子类实现具体逻辑。

## 4. **重载（Overloading）和重写（Overriding）有什么区别？**

**答案**：

- **重载**：同一类中方法名相同，参数列表不同。
- **重写**：子类对父类方法的重新实现，方法签名需一致。

## 5. **String、StringBuilder、StringBuffer的区别是什么？**

**答案**：

- `String`：不可变，适合少量字符串操作。
- `StringBuilder`：可变，线程不安全，适合单线程场景。
- `StringBuffer`：可变，线程安全，适合多线程场景。

## 6. **`final`关键字的作用是什么？可以应用于哪些场景？**

**答案**：

- 用于修饰类、方法、变量。
- **final类**：不能被继承。
- **final方法**：不能被重写。
- **final变量**：值不可变（常量）。

## 7. **`static`关键字有什么作用？**

**答案**：

- 用于修饰类变量和方法，使之属于类本身而非实例。
- **static变量**：在类加载时初始化，所有实例共享。
- **static方法**：无需实例化类即可调用。

## 8. **Java中的构造方法有什么特点？什么时候会调用构造方法？**

**答案**：

- 构造方法与类名相同，无返回值，不能声明`void`。
- 在对象创建（`new`）时调用。

## 9. **什么是抽象类？什么是接口？它们有什么区别？**

**答案**：

- **抽象类**：可包含具体方法，不能实例化，有构造函数。
- **接口**：只能包含抽象方法（Java 8后可有`default`方法），所有方法默认`public`。
- 区别在于接口表示能力，抽象类表示一种层次关系。

## 10. **`this`和`super`关键字的作用分别是什么？**

**答案**：

- **this**：引用当前对象，可访问当前类成员。
- **super**：引用父类对象，可访问父类成员。

## 11. **什么是Java中的异常？异常的分类有哪些？**

**答案**：

- **异常**：程序运行时的错误事件，导致正常流程中断。
- **分类**：
    - **受检异常**（`Checked Exception`）：编译期检查，如`IOException`。
    - **非受检异常**（`Unchecked Exception`）：运行时异常，如`NullPointerException`。

## 12. **`try-catch-finally`块中，`finally`是否一定会执行？如果在`try`或`catch`中有`return`语句，`finally`还会执行吗？**

**答案**：

- `finally`块几乎总会执行，即使`try`或`catch`中有`return`。
- 唯一例外是系统退出或线程死亡。

## 13. **什么是多态？多态的实现方式有哪些？**

**答案**：

- **多态**：同一接口多种表现形式。
- **实现方式**：方法重载、方法重写。

## 14. **什么是`Java Virtual Machine`（JVM）？JVM的主要组成部分有哪些？**

**答案**：

- JVM是Java程序的运行环境，负责内存管理、加载类、解释和执行字节码。
- **主要组成**：类加载器、运行时数据区、执行引擎、垃圾回收器等。

## 15. **什么是包装类？自动装箱和拆箱是什么？**

**答案**：

- 包装类将基本数据类型包装成对象（如`Integer`、`Double`）。
- **自动装箱**：基本类型自动转换为包装类。
- **拆箱**：包装类自动转换为基本类型。

## 16. **什么是泛型？泛型的好处是什么？可以使用基本数据类型作为泛型吗？**

**答案**：

- 泛型允许在编译时检查类型安全。
- 提高代码复用性，减少类型转换。
- 不可以直接使用基本数据类型，需用包装类。

## 17. **Java中`HashMap`和`Hashtable`的区别是什么？**

**答案**：

- `HashMap`是线程不安全的，允许`null`键值。
- `Hashtable`是线程安全的，不允许`null`键值。

## 18. **`ArrayList`和`LinkedList`的区别是什么？**

**答案**：

- `ArrayList`基于动态数组，随机访问快，增删慢。
- `LinkedList`基于链表，增删快，随机访问慢。

## 19. **`Array`和`ArrayList`有什么区别？**

**答案**：

- `Array`是定长的，不能调整大小。
- `ArrayList`是动态数组，长度可变。

## 20. **Java中的访问控制符有哪些？它们的作用范围是什么？**

**答案**：

- **public**：对所有类可见。
- **protected**：对同包和子类可见。
- **default**（无修饰符）：对同包可见。
- **private**：仅对本类可见。

## 21. **`public`、`protected`、`default`（无修饰符）、`private`的区别是什么？**

**答案**：

- 见上题。

## 22. **什么是序列化？为什么需要序列化？如何实现对象的序列化？**

**答案**：

- 序列化是将对象转换为字节流，用于网络传输或持久化。
- 需实现`Serializable`接口，通过`ObjectOutputStream`序列化。

## 23. **如何在Java中实现单例模式？单例模式有哪些实现方式？**

**答案**：

- **饿汉式**、**懒汉式**、**双重检查锁**、**静态内部类**、**枚举单例**。
- 最佳方式：枚举实现，防止反序列化和反射攻击。

## 24. **`synchronized`关键字的作用是什么？在哪些场景中需要使用` synchronized`？**

**答案**：

- 确保线程安全，锁住方法或代码块。
- 在并发环境下保护共享资源。

## 25. **什么是内存泄漏？Java中如何防止内存泄漏？**

**答案**：

- 内存泄漏指对象占用内存但不可访问。
- 防止方法：手动清理、使用弱引用，避免长生命周期对象持有短生命周期对象。

## 26. **接口中能否定义`default`方法？它的作用是什么？**

**答案**：

- 可以。用于提供默认实现，避免破坏现有实现类。

## 27. **Java 8中的Lambda表达式是什么？为什么引入Lambda表达式？**

**答案**：

- Lambda表达式是简化匿名内部类的语法。
- 引入Lambda表达式使代码简洁，支持函数式编程。

## 28. **Java 8中的`Optional`类是什么？它的主要用途是什么？**

**答案**：

- `Optional`避免`null`，优雅地处理空值。

## 29. **`abstract`关键字的作用是什么？抽象类和普通类有什么区别？**

**答案**：

- `abstract`用于定义抽象类和抽象方法。
- 抽象类不能实例化，普通类可以。

## 30. **Java中什么是反射？反射的应用场景有哪些？**

**答案**：

- 反射允许在运行时动态获取类的信息。
- 场景：框架、注解处理、动态代理等。

## 31. **在Java中如何创建不可变对象？**

**答案**：

- 用`final`修饰类和所有字段，不提供修改方法。

## 32. **`System.out.println()`是怎么实现的？`System`类中的`out`是什么？**

**答案**：

- `System.out`是`PrintStream`类型的静态字段。
- `println()`最终调用`PrintStream`的`write()`方法。

## 33. **Java中的强引用、软引用、弱引用、虚引用分别是什么？**

**答案**：

- **强引用**：不会被回收。
- **软引用**：内存不足时回收。
- **弱引用**：GC时回收。
- **虚引用**：不会决定对象生命周期。

## 34. **`hashCode()`和`equals()`的关系是什么？为什么要重写这两个方法？**

**答案**：

- `equals()`相等则`hashCode()`必须相同。
- 重写确保对象在`HashMap`等集合中正确存取。

## 35. **Java中如何实现深拷贝和浅拷贝？**

**答案**：

- **浅拷贝**：直接复制对象，原对象字段引用不变。
- **深拷贝**：需要实现`Cloneable`接口并重写`clone()`方法，将对象及其引用的对象均复制。

## 35. 如下程序将输出什么？

在类中的静态方法

```java
package tests;

public class Test {

    public static String toString(){
        System.out.println("Test toString called");
        return "";
    }
    
    public static void main(String args[]){
        System.out.println(toString());
    }
}
```

**答案**：
以上**代码不能编译**。因为所有类对继承根对象类Object。以上会编译错误提示静态方法不能覆盖实例方法。

## 36. 如下程序将输出什么？

静态方法调用

```java
package tests;

public class Test {

    public static String foo(){
        System.out.println("Test foo called");
        return "";
    }
    
    public static void main(String args[]){
        Test obj = null;
        System.out.println(obj.foo());
    }
}
```

**答案**：
**编译器做了编译优化**。在java编译转换成字节码时，它指向的foo()是静态方法，而不是对象方法，因此**编译从`obj.foo()`调整到`Test.foo()`**，于是就没有了`NullPointerException`异常。

## 37. java在方法调用时是通过值传递还是引用传递？

**答案**：
值传递

## 38. System类的用途是什么？

**答案**：

System类是核心类之一，它被声明为final的。因此无法被子类继承和覆盖其行为。也不提供任何公共构造器，因此也不能实例化这个类。也是为什么它的所有方法是静态static的原因。提供了**打印日志、数组拷贝、获取当前时间、读环境变量等助手**的方法

## 38. java反射API是什么？为什么有它非常重要？

**答案**：
java反射API**提供查看和修改java应用程序的运行时行为**的能力。我们可以查看java类，接口，枚举和它们的方法和域的详情。反射API是一个高级主题，一般的应用中应当避免它。反射API用于反设计模式的场景，如单例模式中调用私有构造器，建返访问修饰调用。

即然一般的应用中应当避免使用反射API，但有它的话还是非常重要。因为我们不能没有如Spring，Hibernate或者Tomcat服务，JBoss之类的框架。它们通过反射API调用适当的方法和实体，使用它做了许多处理。

## 39. java中main方法的重要性是什么？

**答案**：
main()方法是任何独立的java应用程序的入口点。main的语法是：`public static void main(String args[])`.

main方法是公用且静态的，输入参数是数组，可以转入运行时参数给它。

## 40. 能重载main方法吗？

**答案**：
可以，在类中可以有多个main名字的方法。然而运行时的入口仅查找这个方法`public static void main(String args[])`.

## 41. 序列化Serialization和反序列化Deserialization是什么？

**答案**：
java对象转换成二进制流的过程被称做为序列化，把二进制流数据转换成对象的过程被称做为反序列化。对象序列化后就可以通过`java.io.ObjectOutputStream`写入对象到文件或者任何输出流OutputStream对象，实现网络发磅或套接字连接使用
