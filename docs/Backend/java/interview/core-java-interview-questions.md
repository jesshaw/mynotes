# java核心技术面试问题

在许多面试中，java核心技术是喜欢考察的知识点，并且在决定你的面试结果中扮演关键的角色。这篇文章关于java核心技术的问题，它直接来自于我10多年java编程和许多面试经历。

我已经写过许多java面试问题的具体文章，如字符串String，集合Collections和多线程Multithreading等主题。

这里我先给出一些重要的java核心技术面试问题。

## 1. java发布了什么重要特性？

### java 23

Java 23 带来了许多新特性和改进，以下是一些重要的更新：

1. **模式匹配中使用原始类型** (`JEP 455`)：这是模式匹配功能的一个预览特性，允许在模式匹配、`instanceof` 和 `switch` 表达式中使用原始类型，这样可以使代码更加简洁和易读。

2. **类文件API** (`JEP 466`)：这是一个处于第二次预览阶段的功能，提供了操作类文件的API，这可能对那些需要处理字节码的工具非常有用。

3. **Markdown格式文档注释** (`JEP 467`)：允许使用Markdown语法来编写Javadoc，使得API文档更容易编写和阅读。

4. **向量API** (`JEP 469`)：这是一个正处于第八次孵化阶段的功能，旨在提供硬件加速的向量计算支持，从而改善数值计算的性能。

5. **流收集器** (`JEP 473`)：这个特性也是处于第二次预览阶段，它允许创建自定义的流中间操作，增强流API的功能。

6. **标记sun.misc.Unsafe中的内存管理方法为过时** (`JEP 471`)：为了提升安全性，`sun.misc.Unsafe`类中的内存管理方法被标记为过时，并计划移除。

7. **ZGC：默认分代收集模式** (`JEP 474`)：ZGC垃圾收集器现在默认启用分代收集模式，这可以改善应用程序的垃圾回收性能。

8. **模块导入声明** (`JEP 476`)：这是一个预览特性，简化了模块间的依赖声明，使得模块化应用程序更加容易管理。

9. **隐式声明的类和实例主方法** (`JEP 477`)：这是第三个预览版本，允许更简便地创建和使用类。

10. **结构化并发** (`JEP 480`)：这是结构化并发特性的第三个预览版本，简化了并发编程，并提高了错误处理的能力和可观察性。

11. **作用域值** (`JEP 481`)：这是一个处于第三次预览的功能，提供了作用域值的概念，可能用于线程局部存储或其他需要隔离状态的场景。

12. **灵活的构造函数主体** (`JEP 482`)：这是处于第二次预览的功能，允许构造函数在调用超类构造器之前执行代码，增加了构造函数的灵活性。

除了这些语言层面的特性外，Java 23 还包括了一些性能上的改进和其他API上的增强，以及对工具和服务的支持，比如Java Management Service (JMS) 9.0。这些改进都旨在提升开发者的生产力，并且更好地服务于企业和开发者的需求。

### java 8

java 8于2014年3月发布，因此是java面试中的热点问题。如果你清楚的回答这个问题，将展示出你对新技术的关注度。

在java 5引入注解和泛型后，java 8是最大（变化）的发布版之一。 java 8有如下重要新特性：

1. [接口可以带默认和静态方法。](https://www.journaldev.com/2752/java-8-interface-changes-static-method-default-method)
2. [函数式接口和Lambda表达式。](https://www.journaldev.com/2763/java-8-functional-interfaces)
3. [为集合引入的java Stream API。](https://www.journaldev.com/2774/java-8-stream)
4. [java 新的日期时间API。](https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant)

强烈推荐打开链接了作深入理解，也可以看一下java 8的新特性。

## 2. 你对java的平台独立性Platform independence的理解是什么？

平台独立性意思是在任何操作系统中运行同样的java程序。例如你可以在Windows上写java程序运行在Mac OS上。

## 3. JVM是什么？JVM是平台独立的吗？

JVM是java虚拟机（Java Virtual Machine）的缩写，它是java语言的核心。JVM的责任就是转换字节码到可读的机器码。JVM不是平台独立的，也是为什么我们在不同的操作系统需要不同的JVM的原因。我们用java可选项可以自定义分配内存最小和最大值。java虚拟机之所以被叫做虚拟，是因为他提了一个不依赖于底层操作系统的接口。

## 4. JDK和JVM的区别是什么？

JDK是java开发工具包（java Development Kit）的缩写，它是用于开发目的工具集合。JVM是执行java程序的部分。  

JDK除了包含了一批用于Java开发的组件，还包含JRE,java运行时环境，也包括了用于产品环境的各种库类，如基础类库rt.jar，以及给开发人员使用的补充库，如国际化与本地化的类库、IDL库等等。JDK中还包括各种样例程序，用以展示Java API中的各部分。

JVM是java平台的可执行的部分。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。由于JVM并不是专为Java所实现的运行时，实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。

## 5. JVM和JRE的区别是什么？

JRE是java运行时环境的缩写（Java Runtime Environment），它是JVM的一种实现。JRE由JVM,java二节文件和其他成功执行任何程序的其他类组成。JRE不包含任何像编译器、调试器等那样的开发工具。如果你想执行任何java程序，你应当安装JRE。

## 6. 所有类的的超类是哪个类？

`java.lang.Object`是所有类的根类，不需要扩展它。

## 7. 为什么java不支持多继承？

因是“钻石问题（菱形继承问题）” 导致java类不支持多继承。想了解更多“钻石问题”，请阅读[java中的多继承](https://www.journaldev.com/1775/multiple-inheritance-in-java)。

然后多继承在接口中是支持的。一个接口可以扩展多个接口，因为仅仅是声明方法，实现类中将实现它接口的方法。因此在接口中就没有“
钻石问题（菱形继承问题）”了。

## 8. 为什么java不是纯面向对象的语言？

说java不是纯面向对象语言，是因为它支持如int、byte、short、long等**原始类型**。我相信在写代码时它带来了简捷性。很显然地java有原始类型对应的包装类型表示，众所周知，包装类型除了添加了一些方法，它们没有带来任何好处。

## 9. PATH和CLASSPATH变量的区别是什么？

`PATH`是一个用在操作系统中定位可执行文件的环境变量（不仅java可执行文件，还有其他如C#,C++等可执行文件）。这就是为什么在安装java时或想任何可执行文件被找到时，我们需要配置目录路径到Path变量的原因。

`CLASSPATH`是为java指定的用于java可执行文件定位class字节文件的路径变量。在运行java应用程序时将查找这个`CLASSPATH`路径，它可以是目录、ZIP文件、JAR文件等。

## 10. java中main方法的重要性是什么？

main()方法是任何独立的java应用程序的入口点。main的语法是：`public static void main(String args[])`.

main方法是公用且静态的，输入参数是数组，可以转入运行时参数给它。

## 11. 能重载main方法吗？

可以，在类中可以有多个main名字的方法。然而运行时的入口仅查找这个方法`public static void main(String args[])`.

## 12. java中的重载overloading和覆载overriding是什么？

在一个类中有相同名称的方法、不同参时，我们称它为`重载overloading`。

`覆载overriding`指的是父子类之间存在相同签名的方法。在子类中可以使用@Override注解覆盖父类的方法。

## 13. 在一个java源文件中能有多个公共类吗？

在单个java源文件中，不能超过一个公共类。但单个源文件中可以有多个非公共的类。

## 14. java包是什么？那个包默认被引入？

java包是组织java类文件的一种机制。这个组织逻辑可以基于功能或模块。一个类的完整类名应包含包及类名，例如，`java.lang.Object`是Object类的完整类名，它是java.lang包的一部分。

`java.lang`包是被默认引入的，任何类中它不需要明确引入。

## 15. java的访问修饰符有哪些？

Java 中的访问修饰符是用来控制类、成员变量、方法和构造函数的可见性和访问级别的关键字。Java 支持四种主要的访问级别：private, default(无修饰符), protected, public。

### 注意

- **构造函数的访问级别**：构造函数的访问级别应该至少与类本身的访问级别一样。
- **静态成员**：静态成员（static）可以具有上述任何一种访问级别。
- **类的访问级别**：类本身也可以有 `public` 或者 `default`（无修饰符）两种访问级别。`public` 类可以在任何地方被访问，而 `default` 类只能在其所在包内被访问。

正确选择访问修饰符可以帮助你实现良好的封装原则，保护类的内部状态，并且只暴露必要的公共接口。这对于维护软件的安全性和稳定性至关重要。

## 16. final关键字有什么作用？

在 Java 中，`final` 关键字是一个非常有用的修饰符，它可以应用于类、变量（包括局部变量、实例变量和类变量）、方法等。`final` 的使用目的是为了保证某些特性一旦被设定就不可改变，或者防止某些类型的重写或继承。

java接口的变量默认就是final且静态static的。

## 17. static关键字有什么作用？

在 Java 中，`static` 关键字用于声明类成员（变量、方法、嵌套类等）为类级别的，而不是实例级别的。这意味着它们不属于任何特定的对象实例，而是属于类本身。以下是 `static` 关键字的一些主要用途：

- **static 变量（静态变量）**

    `static` 变量是在类级别声明的变量，而不是对象级别的。这意味着所有该类的实例共享同一个 `static` 变量，而不是每个对象都有自己的副本。

- **static 方法（静态方法）**

    `static` 方法是在类级别声明的方法。这些方法可以通过类名直接调用，而不需要创建类的实例。此外，`static` 方法只能访问 `static` 变量，因为非 `static` 变量和方法属于具体的对象实例，在 `static` 方法中是没有对象实例的上下文的。

- **static 嵌套类（静态嵌套类）**

    `static` 类是定义在一个类内部的类，但它不是内部类（inner class）的实例成员。因此，你可以不用外部类的实例就能创建 `static` 类的实例。

- **static 块（静态块）**

    `static` 块在类被加载到 JVM 时只执行一次，主要用于初始化类的静态成员。

- **static 导入（静态导入）**

    `static` 导入允许你在不使用类名前缀的情况下直接使用类的静态成员。

**合理使用 `static` 可以优化内存使用**，减少不必要的重复，同时也可以简化代码逻辑。然而，**过度使用 `static` 可能会导致代码难以测试和维护**，特别是在涉及依赖注入和模拟对象（mock object）的情况下。

## 18. java中的finally和finalize有什么作用？

`finally`块用作在try-catch块之后你总想执行的东西。甚至在抛出异常时也会执行。它大多用来释放在try块中创建的资源，如关闭文件流、数据库连接或者网络连接等。

`finalize()`是一个Object的protected方法，允许对象在被垃圾回收前执行一些清理工作。然而，由于其实现的不确定性和现代更好的替代方案的存在，如 try-with-resources。finalize() 方法在java9中已被废弃，不推荐使用。

## 19. java `try-with-resources`语句是什么，有什么作用？

java 7的新特性,带资源的try语句，用于自动释放资源，相当于try-catch语句块执行了finnaly块。

## 20. java的多个catch语句块是什么，有什么作用？

如果一个try块中有多个异常要被捕获，catch块中的代码会变丑陋的同时还要用多余的代码来记录异常。有鉴于此，java 7的一个新特征是：一个catch子句中可以捕获多个异常。使用管道符(|),如'catch(IOException | SQLException | Exception ex)'捕获异常。

## 21. 接口是什么，有什么作用?

接口是java语言的核心部分，不但用在许多JDK中而且也用在许多框架、工具和java设计模式中。在java中，**接口提供了一用实现方式的抽象**，用来定义子类需要实现的契约。

在代码中，**接口有利于定义类型起始点和创建顶层结构**。自从java接口能实现多个接口后，在许多场景下，使用**接口更优于超类**。

## 22. 抽象类是什么，有什么作用？

抽象类为子类**创建一些默认方法的实现**。抽象类可以**有未实现的抽象方法**。

abstract关键字用来创建抽象类。抽象类不能被实例化，大多是用于**子类的扩展**。

## 23. 抽象类和接口有什么区别？

1. abstract用于创建抽象类，而interface用来创建接口。
1. 子类用extends扩展抽象类，而接口使用implements实现接口。
1. 抽象类可以有实现方法，但接口没有。
1. 抽象类有构造器，但接口没有。
1. 抽象类的方法有public, private, protected, static修饰符，但接口的方法是隐式的public和abstract，不需要使用任何的修饰符。
1. 一个类只能扩展最多一个抽象类，但接口可以扩展一个或多个接口。
1. 抽象类可以扩展其他类和实现其他接口，但接口只能扩展其他接口。
1. 抽象类有main入口方法，是可以运行的，但时接口不能。
1. 接口常用来定义契约，但抽象定义契约的同时还可以有方法实现。

## 24. 接口能否实现或扩展另一个接口？

接口**不能实现另一个接口，但可以扩展它**。因为接口没有实现就没有“钻石问题”。

## 25. 标记接口Marker interface是什么，有什么作用？

标记接口是一个**没有任何方法实现的空接口**，用于**标记实现类有某些功能**。从所周知的Serializable和Cloneable就是标记接口。

## 26. 包装类是什么？

java包装类是8个原始类型对应的对象表示形式。所有的包装类都是不能被继承final和一成不变immutable的。

## 27. java中的枚举是什么？

枚举作为一个新类型，在java 1.5版本引入。它的域由一些固定的常量构成。如，在java中可以使用EAST, WEST, NORTH, SOUTH创建Direction方向的枚举。

与类相似，我们使用enum关键字用于创建一个枚举类型。枚举常量是隐式的静态不能继承的。

## 28. java注解是什么？

java注解提供关于代码的描述信息。它不直接影响代码。注解在java5中被引入。注解是关于嵌套在程序自己中的元数据。可以用过注解解析工具或编译器解析。我们常指定注释在编译时或者在运行时可用。java盎的注解有@Override, @Deprecated and @SuppressWarnings。 

## 29. java反射API是什么？为什么有它非常重要？

java反射API**提供查看和修改java应用程序的运行时行为**的能力。我们可以查看java类，接口，枚举和它们的方法和域的详情。反射API是一个高级主题，一般的应用中应当避免它。反射API用于反设计模式的场景，如单例模式中调用私有构造器，建返访问修饰调用。

即然一般的应用中应当避免使用反射API，但有它的话还是非常重要。因为我们不能没有如Spring，Hibernate或者Tomcat服务，JBoss之类的框架。它们通过反射API调用适当的方法和实体，使用它做了许多处理。

## 30. java中的组合（Composition）是什么？

组合是在类中**实现`有has-a`关系的一种设计**技术。使用对象组合是为了代码重用。

java组合通过引用其他对象的实例变量实现的。使用组合的好处是，我们**能够控制其他对象的可见性**，在我们需要的时候重用。

## 31. 组合相对与继承有什么好处？

java编程的最佳实践之一是**组合（Composition）优于继承（Inheritance）**。有以下原因：

* 尽管我们可以不使用超类的方法，但在超类中的任何改变也可能影响到子类。例如，假如我们在子类中有一个方法`test()`，突然某人在父类引入一个方法`test()`，那么我们在子类中出现编译错误。组合从没有这种问题，是因为我们仅在需要方法时才使用。
* 若我们在设计超类时没有掌控，继承会暴露了所有超类的方法和变量到客户端，这样也能导致安全漏洞。组合允许我们对方法提供限制的访问，因此更加安全。
* 在组合中我们可以运行时绑定，继承绑定是在编译时。因此组合的方法调用更加灵活。

你可以在[java组合vs继承](https://www.journaldev.com/1775/multiple-inheritance-in-java)一文中，阅读更多关于组合优于继承的知识。

## 32. java中怎样对自定义对象集合进行排序？

在 Java 中，对自定义对象的集合进行排序有几种常见的方式。这些方法可以根据你使用的集合类型和个人偏好来选择。下面列出了一些常见的排序方法：

1. 实现 `Comparable` 接口实现`compareTo` 方法
2. 使用 `Comparator`接口的`compare` 方法

## 33. java中的内部类是什么?

我们把定义在类的内部的类称为嵌套类。任何**非静态的嵌套类被称之为内部类**。内部类与类的对象实例相关。它能访问所有变量和外部类的方法。即然内部类是与实例相关，那么它就没有任何静态变量。

在类的内部，可以有本地内部类和匿名内部类。详情请阅读[java内部类](https://www.journaldev.com/996/java-inner-class)。

## 34. 匿名内部类是什么？

在 Java 中，**匿名内部类**（Anonymous Inner Class）是一种特殊的内部类，它没有名字并且没有显式的构造函数。匿名内部类通常用于在创建一个类的实例的同时定义该类，这种类只在创建时使用一次，因此不需要给它命名。匿名内部类通常用于实现接口或者继承一个类，并且只需要覆盖其中的一个或几个方法。

### 匿名内部类的特点

1. **没有名称**：由于匿名内部类没有名字，因此它不能被重复使用。
2. **没有构造函数**：匿名内部类没有构造函数，它的构造逻辑包含在类定义本身中。
3. **自动实现接口或继承类**：匿名内部类可以实现一个接口或继承一个类，并覆盖所需的抽象方法。
4. **方便简短**：适合快速定义一些简单逻辑的小型类，尤其是在需要立即使用的地方。

### 创建匿名内部类的步骤

创建匿名内部类的基本步骤如下：

1. 定义一个接口或父类。
2. 在需要使用该类的地方，直接使用 `new` 关键字加上接口或父类的名字，接着是一个类体。

## 35. java类加载器Classloader是什么？

java类加载器是在我们想访问任何类时，加载字节码程序到内存的一种程序。我们也可以扩展ClassLoader类和覆载loadClass(String name)方法定义自己的类加载器。了解更多关于[java类加器](https://www.journaldev.com/349/java-classloader)。

## 36. 类加载器的不同类型是什么？

在java中提供以下三个内建的类加载器：

1. 引导类加载器（Bootstrap Class Loader）：它用来加载JDK内存类，典型的加载rt.jar和其他核心类。它是用原生代码来实现的，并不继承自 java.lang.ClassLoader。
2. 扩展类加载器（Extensions Class Loader）：它用来加载 JDK 的扩展库。常常加载$jAVA_HOME/lib/ext目录库。
3. 系统类加载器（System Class Loader）：它根据 java 应用的类路径（CLASSPATH）来加载 java 类。一般来说，java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。

## 37. java中的三元操作符是什么？

java三元操作符仅是一个带三个表达式的条件操作符。可以使用if-then-else语句替换。例如`a==b?a:b`。

## 38. super关键字做什么用的？

super 关键字在 Java 中主要用于以下方面：

1. 访问父类的成员变量。
1. 调用父类的方法。
1. 调用父类的构造函数。
1. 区分子类和父类中同名的成员变量或方法。

访问构造器**须放在第一条语句**且**只能在构造器中访问**。

## 39. break和continue语句是什么，怎么用？

放在循环语句中用来结束循环，break结束整个循环，continue结束本次循环。

## 40. this关键字是什么，怎么用？

用于访问当前对象的引用。大多被用于确保是当前对象的变量（相对于入参变量来说），也可以用来调用当前对象的其他构造器。

## 41. 默认构造器是什么？

类的**无参构造器被称为默认构造器**。在我们**没有定义任何类构造器时，java编译器会自动创建类的默认无参构造器**。如果定义了有其他构造器，则编译器不会为我们创建默认构造器。

## 42. try可以不带catch语句块吗？

可以。可以有try-finally语句块，于是就避免带catch语句块了。

## 43. 垃圾收集器Garbage Collection是什么？

垃圾收集器查看**堆内存的处理器**，识别哪个对象在使用中和哪个不在使用中，然后删除不使用的对象。销毁内存是通过垃圾收集器自动进行处理的。

我们可以使用代码`Runtime.getRuntime().gc()`或者使用工具方法`System.gc()`运行垃圾收集器。更多堆内存和垃圾收集器详细分析，请阅读“[垃圾收集器](https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java)”。

## 44. 序列化Serialization和反序列化Deserialization是什么？

我们把java对象转换成二进制流的过程被称做为序列化。一旦一个对象被转换成二进制流，它就可以写入到文件或通过网络发送或在套接字连接中使用。

对象应当实现序列化Serializable接口，这样我们就可以使用`java.io.ObjectOutputStream`写入对象到文件或者任何输出流OutputStream对象了。阅读更多[java序列化](https://www.journaldev.com/927/objectoutputstream-java-write-object-file)知识。

把二进制流数据转换成对象的过程被称做为反序列化。阅读更多[java反序列化](https://www.journaldev.com/933/objectinputstream-java-read-object-file)知识。

## 45. 通过命令提示行怎样运行JAR文件？

能使用命令行运行jar包文件，但需要在jar清单文件中有Main入口类。含Main的类是jar包的入口点，用来通过java命令执行。

## 46. System类的用途是什么？

java System类是核心类之一，`System.out.print()`是其中一个方法。在调试时，它是最简单的记录日志信息的方法。

System类被声明为final的。因此无法被子类继承和覆盖其行为。也不提供任何公共构造器，因此也不能实例化这个类。也是为什么它的所有方法是静态static的原因。

System类**提供了数组拷贝、获取当前时间、读环境变量等助手类**方法。阅读更多[java System类](https://www.journaldev.com/1847/java-system-java-lang-system-class)知识。

## 47. instanceof关键字的用途是什么？

instanceof关键字用来检测是否属于某个类。我们应当尽可能的避免使用它。

## 48. switch case语句中能使用字符串类型吗？

java 7引入的新特性之一，switch case语句中可以使用字符串类型。因此java 7或更高版本可以使用。

## 49. java在方法调用时是通过值传递还是通过引用传递？

这个问题非常具有迷惑性。我们知道对象变量在堆空间中包含引用的对象。在我们调用任何方法时，这个变量的拷贝被转递并存储在方法的栈内存中。我们能够检测到任何语言它是通过引用或通过值传递通过一个简单的交换方法，请阅读[更多](https://www.journaldev.com/3884/java-is-pass-by-value-and-not-pass-by-reference)。由此我们得出**java方法调用是通过值传递**而不是通过引用传递的。

## 50. 堆Heap和栈Stack内存有什么区别？

堆和栈主要的区别如下：

- 所有应用的部分都使用堆内存，然而**只有执行线程使用栈内存**。
- 每当对象被创建时，它总是存在堆空间中，栈内存包含它的引用。**栈内存仅包括本地的原始变量和在堆空间中的对象的引用变量**。
- **栈内存是通后进先出LIFO的方法管理**的，然而在堆内存中因为它是全局使用，所以它的管理方式更加复杂。

在同一程序中更加详细的解释，请阅读[java堆vs栈内存](https://www.journaldev.com/4098/java-heap-space-vs-stack-memory)

## 51. java编译器是存储在JDK，JRE或JVM哪一个中？

java编译器的任务是转换java程序到字节码，我们使用`javac`命令执行即可实现。因此它必须要存在JDK中。

## 52. 如下程序将输出什么？

- 在类中的静态方法

```java
package tests;

public class Test {

    public static String toString(){
        System.out.println("Test toString called");
        return "";
    }
    
    public static void main(String args[]){
        System.out.println(toString());
    }
}
```

答：以上代码不能编译。因为所有类对继承根对象类Object。以上会编译错误提示静态方法不能覆盖实例方法。

- 静态方法调用

```java
package tests;

public class Test {

    public static String foo(){
        System.out.println("Test foo called");
        return "";
    }
    
    public static void main(String args[]){
        Test obj = null;
        System.out.println(obj.foo());
    }
}
```

答：这是个奇怪的使用场景。NULL空对象调用方法是总会报`NullPointerException`异常，且该方法是属于类的静态方法，但该程序能工作并打印"Test foo called"。

原因是编译器做了编译优化。在java编译转换成字节码时，它指向的foo()是静态方法，而不是对象方法，因此编译从`obj.foo()`调整到`Test.foo()`，于是也没有了`NullPointerException`异常。

## 参考

[原文](https://www.journaldev.com/2366/core-java-interview-questions-and-answers#public-class)