# MySql 相关知识

## 事务的隔离级别

### 名词解释

| 问题类型       | 描述                                                                 | 示例场景                                                                 |
|----------------|--------------------------------------------------------------------|------------------------------------------------------------------------|
| **脏读**       | 读取了其他事务未提交的数据。                                           | 事务 A 读取了事务 B 未提交的修改，事务 B 回滚后数据无效。                   |
| **不可重复读** | 同一事务中多次读取同一数据，结果不一致。                                 | 事务 A 读取数据后，事务 B 修改并提交，事务 A 再次读取时数据已改变。           |
| **幻读**       | 同一事务中多次查询同一范围的数据，结果集不一致（新增或删除了符合条件的数据）。 | 事务 A 查询范围数据后，事务 B 插入或删除了符合条件的数据，事务 A 再次查询时结果集变化。 |

### 隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|----------|------|-------------|------|
| READ UNCOMMITTED (读未提交) | 可能 | 可能 | 可能 |
| READ COMMITTED (读已提交) | 不可能 | 可能 | 可能 |
| REPEATABLE READ (可重复读) | 不可能 | 不可能 | 可能 |
| SERIALIZABLE (串行化) | 不可能 | 不可能 | 不可能 |

在 MySQL 中，默认的隔离级别是 可重复读（Repeatable Read），它通过多版本并发控制（MVCC）避免了脏读和不可重复读，但在某些情况下仍可能出现幻读。

### MVCC 与 设计表的`version` 字段的对比

在设计表时是否需要增加 `version` 字段，取决于具体的业务场景和需求。虽然 MySQL 的 InnoDB 存储引擎已经通过 MVCC 实现了多版本并发控制，但 MVCC 主要用于解决 **读写并发** 和 **一致性读** 的问题，而 `version` 字段通常用于解决 **写写并发** 的问题（即乐观锁机制）。以下是详细分析：

| 特性                | MVCC                          | `version` 字段（乐观锁）         |
|---------------------|-------------------------------|----------------------------------|
| **解决什么问题**     | 读写并发、一致性读             | 写写并发                         |
| **实现方式**         | 通过隐藏字段、Undo Log 和 Read View | 通过业务字段（如 `version`）      |
| **性能开销**         | 较低                          | 较高（需要额外字段和逻辑）        |
| **适用场景**         | 读多写少、一致性读需求高       | 写多读少、高并发写需求           |


## 事务的特点 - ACID

- **原子性（Atomicity）**：事务中的所有操作要么全部完成，要么全部不完成。
- **一致性（Consistency）**：事务执行前后，数据库必须保持一致状态，满足业务规则约束。
- **隔离性（Isolation）**：并发执行的事务互相隔离，互不影响。
- **持久性（Durability）**：一旦事务提交，其结果是永久性的，即使系统故障也能恢复。

## SQL 连接类型及语法

- **左连接（Left Join）**：返回左表的所有记录，以及右表中匹配的记录；如果右表没有匹配，则结果为NULL。

  ```sql
  SELECT a.*, b.* FROM a LEFT JOIN b ON a.b_id = b.id;
  ```

- **右连接（Right Join）**：返回右表的所有记录，以及左表中匹配的记录；如果左表没有匹配，则结果为NULL。

  ```sql
  SELECT a.*, b.* FROM a RIGHT JOIN b ON a.b_id = b.id;
  ```

- **内连接（Inner Join）**：仅返回两个表中匹配的记录。

  ```sql
  SELECT a.*, b.* FROM a INNER JOIN b ON a.b_id = b.id;
  ```

## 常用聚合函数及其作用

- **COUNT(*|列)**：计算指定列或整个表中的记录数。
- **SUM(列)**：计算指定列的总和。
- **AVG(列)**：计算指定列的平均值。
- **MAX(列)**：返回指定列的最大值。
- **MIN(列)**：返回指定列的最小值。

示例：

```sql
SELECT MAX(age) FROM t_student;
SELECT MIN(age) FROM t_student;
```

## 数据库设计的三大范式及反范式

1. **第一范式（1NF）**：确保每列都是不可再分的原子列。
2. **第二范式（2NF）**：在满足第一范式的前提下，非主键字段完全依赖于主键。
3. **第三范式（3NF）**：在满足第二范式的前提下，消除传递依赖。

**反范式设计**：

- **提高查询效率**：通过冗余存储一些数据来减少多表联查的需求，适用于读多写少的场景。
- **保存历史快照信息**：某些情况下，需要保留特定时间点的数据快照，比如订单中的收货人信息，以防止后续变更导致的历史数据丢失。

反范式设计虽然提高了查询性能，但也增加了数据冗余和维护成本，因此需要根据具体应用场景权衡使用。
