---
title: js对象创建：模式和最佳实践
tags: js,object create,js对象创建,js类,最佳实践
categories: 
  - js

thumbnail: /gallery/blue-water15.jpg
---

js对象的创建是一个棘手的主题。 这种语言有很多创建对象的风格，新手和老手都会感到不知所措，不知道应该使用哪一种。 但是，尽管每种语法都有不同的语法，但是它们可能比您实现的更类似。 在这篇文章中，我将带您了解各种不同风格的对象创建，以及如何逐步建立对象。
<!-- more -->

## 对象字面量（Object Literals）

我们游览的第一站是创建对象的绝对最简单的方法，即对象字面量。 js宣称对象可以创建“ex nilo”，无中生有 - 没有类，没有模板，没有原型 - 只是poof，一个包含方法和数据的对象。
```js
var o = {
  x: 42,
  y: 3.14,
  f: function() {},
  g: function() {}
};
```
但是缺点是：如果我们需要在其他地方创建相同类型的对象，那么我们最终会复制粘贴对象的方法，数据和初始化。 我们需要一种方法来创建不仅仅是一个对象，而是一个对象的家族。

## 工厂函数（Factory Functions）

我们巡演的下一站是工厂函数。这是创建共享相同结构，接口和实现的对象族的绝对最简单的方法。 而不是直接创建对象字面量，而是从函数返回对象字面量。这样，如果我们需要多次或在多个地方创建相同类型的对象，我们只需要调用一个函数。
```js
function thing() {
  return {
    x: 42,
    y: 3.14,
    f: function() {},
    g: function() {}
  };
}

var o = thing();
```
但是缺点是：这种方法会导致内存膨胀，因为每个对象都包含每个函数的唯一副本。 理想情况下，我们希望每个对象只能共享一个函数副本。

## 原型链（Prototype Chains）

js为我们提供了一个内置的机制来共享跨对象的数据，称为原型链。当我们访问一个对象的属性时，它可以通过委托给其他对象来满足这个请求。我们可以使用它并更改我们的工厂函数，以便它创建的每个对象只包含该特定对象唯一的数据，并将所有其他属性请求委托给一个共享对象。
```js
var thingPrototype = {
  f: function() {},
  g: function() {}
};

function thing() {
  var o = Object.create(thingPrototype);

  o.x = 42;
  o.y = 3.14;

  return o;
}

var o = thing();
```

事实上，这是一种常见的模式，语言已经内置了对它的支持。我们不需要创建自己的共享对象（原型对象）。相反，我们会自动为每个函数创建一个原型对象，我们可以将共享数据放在那里。
```js
thing.prototype.f = function() {};
thing.prototype.g = function() {};

function thing() {
  var o = Object.create(thing.prototype);

  o.x = 42;
  o.y = 3.14;

  return o;
}

var o = thing();
```
但是有一个缺点。 这将导致一些重复。“thing”函数的第一行和最后一行将在每个这样的委托原型工厂函数中几乎逐字地重复。

## ES5类

我们可以通过将重复行移动到自己的功能来隔离重复行。这个函数会创建一个委托给其他任意函数原型的对象，然后用新创建的对象作为参数来调用该函数，最后返回该对象。
```js
function create(fn) {
  var o = Object.create(fn.prototype);

  fn.call(o);

  return o;
}

// ...

Thing.prototype.f = function() {};
Thing.prototype.g = function() {};

function Thing() {
  this.x = 42;
  this.y = 3.14;
}

var o = create(Thing);
```
实际上，这也是一种常见的模式，语言对它有一些内置的支持。我们定义的“create”函数实际上是“new”关键字的基本版本，我们可以用“new”代替“create”。
```js
Thing.prototype.f = function() {};
Thing.prototype.g = function() {};

function Thing() {
  this.x = 42;
  this.y = 3.14;
}

var o = new Thing();
```
现在我们已经到达了我们通常所说的ES5类。 它们是将共享数据委托给原型对象并依靠“新”关键字来处理重复性逻辑的对象创建函数。

但是有一个缺点。 它是冗长而丑陋的，实现继承更加冗长和丑陋。

## ES6类

相对而言，js最新增加的是ES6类 ，它为执行相同的操作提供了非常简洁的语法。
```js
class Thing {
  constructor() {
    this.x = 42;
    this.y = 3.14;
  }

  f() {}
  g() {}
}

var o = new Thing();
```
对照多年来，我们的js开发人与原型链有着一种关系，现在你可能遇到的**两种最常见的风格是类语法（即：ES5类和ES6类）**，它严重依赖原型链，工厂函数语法，后者通常不依赖于原型链。 这两种风格在性能和功能上有所不同，但只是略有不同。

## 性能

今天，js引擎已经非常优化，几乎不可能查看我们的代码和更快速的原因。 衡量至关重要。 但有时甚至测量可能会使我们失败。 通常情况下，每六个星期就会发布一次更新的js引擎，有时候性能会发生重大变化，我们之前采取的任何测量以及我们基于这些测量所做出的任何决定都会直接跳出窗口。所以，我的经验法则是支持最官方和最广泛使用的语法，假设它会受到最严格的审查，并且是大部分时间内性能最高的语法。 现在是类的语法，当我写这个时，类语法比返回文字的工厂函数大约快3倍。

## 特征

在ES6中，类和工厂函数之间的功能差异很少。 今天，工厂函数和类都可以通过闭包和类地图来实现真正的私有数据工厂函数。 两者都可以通过将其他属性混合到其自己的对象中来实现多个继承工厂功能，并且还可以通过将其他属性混合到其原型，类工厂或代理中来实现多个继承工厂功能。 如果需要的话，工厂函数和类都可以返回任意的对象。 而且都提供了一个简单的语法。

## 结论

综合考虑来看，我的首选是类语法。 这是标准的，它简单，干净，速度快，它提供了以前只有工厂才能提供的每一个功能。

[原文](https://www.sitepoint.com/js-object-creation-patterns-best-practises/)



